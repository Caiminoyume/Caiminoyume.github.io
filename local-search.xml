<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>TLS 技术鉴赏 —— 1. TLS 的基本原理</title>
    <link href="/2023/08/02/TLS%20%E6%8A%80%E6%9C%AF%E9%89%B4%E8%B5%8F%20%E2%80%94%E2%80%94%201.%20TLS%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <url>/2023/08/02/TLS%20%E6%8A%80%E6%9C%AF%E9%89%B4%E8%B5%8F%20%E2%80%94%E2%80%94%201.%20TLS%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近一直在看关于网络通信的书，正好趁此博客刚刚开站，打算写一系列的文章。若是没人看，权当作笔记了吧。<del>说不定几篇之后就没动力写了</del></p><p>其实网络通信可讲的太多，不过笔者认为，研究网络安全，在攻防角色间相互代换，可称为颇有一番乐趣的智力游戏。于是乎，第一篇的主题就定下来了</p><p>要讨论通信安全，那就不得不先谈密码学了，要达成安全的目的，必然与密码有千丝万缕的联系。不过本篇由于只讲基本原理，并不会对具体的密码算法有过多的讲解，针对下面要讲到的加密方式，将其理解为概念上完美的加密方式即可（即，在不知道密钥的前提下，绝无可能破译）</p><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h3 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h3><p>对称加密很好理解，即双方使用同样的密钥进行加密和解密。用数学的语言表述如下：</p><p>$c&#x3D;K(p)$<br>$K(c)&#x3D;K(K(p))&#x3D;p$</p><p>上述式子中，$p$ 即明文（plaintext），$c$ 即密文（ciphertext），$K$ 即密钥（key），通过密钥对明文加密得到密钥</p><h3 id="不对称加密算法"><a href="#不对称加密算法" class="headerlink" title="不对称加密算法"></a>不对称加密算法</h3><p>不对称加密具有一种特殊的性质，即它使用一个密钥对，私钥加密而公钥解密，公钥加密而私钥解密，公钥&#x2F;私钥都无法对自己加密的内容解密<br>再一次，用数学的语言表达如下：</p><p>$K^+(K^-(p))&#x3D;p$<br>$K^-(K^+(p))&#x3D;p$</p><p>在数学上，密钥对实际没有区别，习惯上，我们将公开出去的密钥叫公钥（publickey），而自己持有的密钥叫私钥（privatekey），式子中，将公钥用 $K^+$ 表示，私钥用 $K^-$ 表示</p><ul><li>由于不对称加密算法资源消耗大，实践中一般不直接用来加密报文，而是用来传递对称加密的密钥</li></ul><h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><p>虽然哈希算法不能叫加密算法，但它在验证原文的完整性时非常重要，也是通信安全中必不可少的一位，因此将它放在这里<br>哈希算法具有这些性质：</p><ol><li>对于任意报文 $m$，都能生成固定长度的字符串（哈希值） $H(m)$</li><li>对于相同的报文 $m$，总是能生成相同的哈希值 $H(m)$</li><li>找到任意两个不同的报文 $x$ 和 $y$，使 $H(x)&#x3D;H(y)$，在计算上是不可能的</li></ol><p>显然哈希算法的输入和输出不是一一对应的，必然会有相当多的报文 $m_1,m_2,\ldots$ 的哈希值相同（这种现象被称为<strong>哈希碰撞</strong>），只是我们无法在合理的时间内根据 $m_1$ 去计算其他和它哈希值相等的报文。这也正是第三条表达的意思</p><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>数字签名是由哈希算法和不对称加密算法结合起来的产物。签名者将报文的哈希值用自己的私钥加密（该加密数据即为<strong>数字签名</strong>），并同报文一起发送给接受者。接受者使用公钥解密，并验证哈希值，即可知晓报文是否被篡改以及验证发送者的身份</p><h3 id="一条加密隧道应该具有的性质"><a href="#一条加密隧道应该具有的性质" class="headerlink" title="一条加密隧道应该具有的性质"></a>一条加密隧道应该具有的性质</h3><p>好了，有了上面这些的工具后，是时候考虑如何建立一条可靠的隧道了，这条隧道应该具有以下性质：</p><ol><li>机密性：密文无法被窃听者理解</li><li>完整性：密文没有被恶意篡改</li><li>端点鉴别：通信双方都要能证实另一方的身份</li></ol><p>接下来开始头脑风暴！</p><h1 id="如何创立可靠的加密信道"><a href="#如何创立可靠的加密信道" class="headerlink" title="如何创立可靠的加密信道"></a>如何创立可靠的加密信道</h1><p>现在设想一台主机 $C$，它现在要去访问名叫 <code>www.example.com</code> 的服务器，开始构想一种方式使它与服务器的通信免受骇客的侵扰吧！</p><h3 id="加密1-0：使用对称加密"><a href="#加密1-0：使用对称加密" class="headerlink" title="加密1.0：使用对称加密"></a>加密1.0：使用对称加密</h3><p>主机 $C$ 运气很好，它一开始就和 <code>www.example.com</code> 拥有同样的（而且只有它们俩知道）对称加密密钥，那事情变得非常简单了，直接使用密钥加密就能保证安全</p><blockquote><p>$client\stackrel{K(p)}{\Longleftarrow&#x3D;&#x3D;\Longrightarrow}server$</p></blockquote><p>但是这种情况是极其少见的，在很多情况下，主机 $C$ 可能是首次和 <code>www.example.com</code> 取得联系<br>并且由一方生成密钥并传输过去也是不行的，在公网上明文传输密钥是极可能被骇客截获，以后的通信就毫无安全可言了</p><h3 id="加密2-0：使用不对称加密"><a href="#加密2-0：使用不对称加密" class="headerlink" title="加密2.0：使用不对称加密"></a>加密2.0：使用不对称加密</h3><p>那么使用不对称加密又如何呢？比如由服务器分发公钥（公钥是可以被任何人知道的），这样主机 $C$ 可以在本地生成对称加密的密钥 $k$，并使用公钥加密传递给服务器了</p><blockquote><p>$client\stackrel{K^+(k)}{&#x3D;&#x3D;&#x3D;\Longrightarrow}server$</p></blockquote><p>很不幸，一个聪明的骇客拦截了服务器发往主机 $C$ 的公钥 $K_{s}^+$，并替换为自己的公钥 $K_{h}^+$，如此，密钥就能被骇客截获</p><blockquote><p>$client\stackrel{K_{h}^{+}(k)}{&#x3D;&#x3D;&#x3D;&#x3D;\Longrightarrow}cracker\stackrel{K_{s}^{+}(k)}{&#x3D;&#x3D;&#x3D;&#x3D;\Longrightarrow}server$</p></blockquote><h3 id="加密3-0：引入-CA"><a href="#加密3-0：引入-CA" class="headerlink" title="加密3.0：引入 CA"></a>加密3.0：引入 CA</h3><p>实际上可以注意到，如果主机 $C$ 除对域名 <code>www.example.com</code> 外，对要访问的服务器一无所知的话，任何加密都是无法验证服务器身份的。就好比你声称要见一个叫“小明”的人，而完全不知道其声音、外貌等等，那么任何人都可以声称自己是“小明”来欺骗你</p><p>但在实际中，主机要去访问一个第一次知道的网站的情况十分常见，<del>比如你现在多半也是第一次见到这个域名，进入笔者的博客</del></p><p>那么，一种自然的想法就是，既然你不可能认识世界上所有人，那么为了保证你见到的人就是“小明”，需要一个神通广大且可靠的朋友作为中介。而在计算机网络里，这个中介就是<a href="https://zh.wikipedia.org/zh-sg/%E8%AF%81%E4%B9%A6%E9%A2%81%E5%8F%91%E6%9C%BA%E6%9E%84">CA</a>（数字证书认证机构，Certificate Authority）</p><h4 id="CA-如何验证身份？"><a href="#CA-如何验证身份？" class="headerlink" title="CA 如何验证身份？"></a>CA 如何验证身份？</h4><p>事实上是，当主机 C 要访问 <code>www.example.com</code> 时，并不会事先去联系 CA（想象一下全世界那么多主机每次访问网站前都要联系 CA 是多么可怕的事），而是由网站的服务器给出 CA 颁发的证书（digital certificate），这“张”证书包含以下数据：</p><ul><li>CA 机构的名称</li><li>服务器的域名</li><li>服务器公钥</li><li>证书的数字签名</li><li>证书的有效期</li><li>其他（主要是协议版本和加解密算法等等）</li></ul><p>那么当主机 $C$ 收到这张证书时会干什么事呢？首先，它会使用证书上的对应 CA 的公钥解密数字签名并验证证书，确定证书的有效性后，提取服务器域名和公钥，后续就可以使用该公钥传递对称加密密钥建立加密信道了</p><p>但是这里似乎有个疑惑，CA 的公钥是从哪里来的呢？答案是，<strong>内置</strong>！在安装浏览器&#x2F;操作系统时，会自带可信任的 CA 名称及其公钥，这样即可达成信任链，完成对证书的验证</p><ul><li>由于 CA 机构的地位，某些流氓浏览器可能会内置一些不具有权威性的 CA，请勿使用除Edge，Chrome，Firefox等大厂以外的浏览器！</li><li>某些恶意软件取得操作系统管理员权限后，也可能安装信任一些不友好的证书！</li><li>一旦信任链一环出现问题，黑客就有可能做到窃听乃至劫持！</li></ul><h4 id="CA机构的风险"><a href="#CA机构的风险" class="headerlink" title="CA机构的风险"></a>CA机构的风险</h4><p>在上述过程中，不难察觉到 CA 的权力过于集中，不免引起人们的担忧：一旦 CA 作恶，后果不堪设想</p><p>CA 可能的风险：</p><ol><li><a href="https://security.googleblog.com/2015/10/sustaining-digital-certificate-security.html">机构人员因某些原因（失误或腐败接受贿赂等）颁发伪造证书</a></li><li>CA 遭受骇客入侵，伪造证书</li><li>CA 受政府压力，给予伪造证书（棱镜门事件中，美国政府可能强迫 CA 为他们颁发假证书）</li></ol><p>关键是，一个中心化的机构总是无法避免此类情况的发生，人们无法完全相信一个集权的机构</p><h3 id="加密4-0：CT制度"><a href="#加密4-0：CT制度" class="headerlink" title="加密4.0：CT制度"></a>加密4.0：CT制度</h3><p><a href="https://zh.wikipedia.org/zh-cn/%E8%AF%81%E4%B9%A6%E9%80%8F%E6%98%8E%E5%BA%A6">CT</a>（证书透明，Certificate Transparency），通过将证书颁发等操作公开，受任何人监督，达到无法篡改和伪造证书的目的</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>如此一来，一条加密信道就在理论上建立起来了</p><p>下面笔者可能（<del>也可能没有，咕咕咕</del>）会花几篇的文章详细讲解 TLS 的具体技术细节，通过预演可能遭到的攻击来梳理 TLS 各种设计的逻辑，敬请期待吧</p>]]></content>
    
    
    <categories>
      
      <category>技术鉴赏</category>
      
      <category>TLS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TLS</tag>
      
      <tag>Network</tag>
      
      <tag>Secure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>折腾tproxy下的一点踩坑</title>
    <link href="/2023/07/28/%E6%8A%98%E8%85%BEtproxy%E4%B8%8B%E7%9A%84%E4%B8%80%E7%82%B9%E8%B8%A9%E5%9D%91/"/>
    <url>/2023/07/28/%E6%8A%98%E8%85%BEtproxy%E4%B8%8B%E7%9A%84%E4%B8%80%E7%82%B9%E8%B8%A9%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>其实早在三天前我就打算写出第一篇博客了，但是由于我国互联网的特殊性，导致安装 hexo 出现了“一点点”小意外。虽然只需要设置一下命令行代理就能搞定</p><p><code>set http_proxy=http://ip:port</code></p><p>但是这件事给我了足够的动力去折腾透明网关。<del>其实早就想搞的，拖延症+懒，就。。。</del></p><h1 id="技术介绍"><a href="#技术介绍" class="headerlink" title="技术介绍"></a>技术介绍</h1><p>tproxy，意为透明代理&#x2F;透明网关，通过在路由器上运行代理软件并劫持局域网内所有流量便可实现局域网设备“无感”翻墙</p><p>它相对与传统的 http 代理或者 sock 代理有以下优点：</p><ol><li>使不支持设置代理的设备翻墙，例如 apple TV，switch等</li><li>使不遵守系统代理的软件走代理</li><li>对代理设备透明，无需对局域网中设备做任何调整</li></ol><ul><li>如果仅是第二条的话，利用 tun 模式即可实现，但这就不在本文的范围内了，请自行查阅相关资料</li><li>目前有许多十分完善的代理插件，如 <a href="https://github.com/vernesong/OpenClash">openclash</a> <a href="https://github.com/jerrykuku/luci-app-vssr">helloworld</a> <a href="https://github.com/xiaorouji/openwrt-passwall">passwall</a> 等，如果你<strong>不</strong>熟悉Linux操作&#x2F;善用Google&#x2F;懂得<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md">提问的智慧</a>，请直接使用插件</li></ul><h1 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h1><p>本文主要参考 <a href="https://xtls.github.io/document/level-2/transparent_proxy/transparent_proxy.html">这个</a>，本文并不打算复述该文章的内容，仅仅对该文没讲到的地方做出补充。特别的，我并没有将网关纳入透明代理中，因为我觉得没必要且相当麻烦（需要排除xray的出站流量）</p><p>总之，我最后的iptables配置如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-attribute">ip</span> rule add fwmark <span class="hljs-number">1</span> table <span class="hljs-number">100</span><br><span class="hljs-attribute">ip</span> route add local <span class="hljs-number">0.0.0.0</span>/<span class="hljs-number">0</span> dev lo table <span class="hljs-number">100</span><br><span class="hljs-attribute">iptables</span> -t mangle -N XRAY<br><span class="hljs-attribute">iptables</span> -t mangle -A XRAY -d <span class="hljs-number">10.0.0.0</span>/<span class="hljs-number">8</span> -j RETURN<br><span class="hljs-attribute">iptables</span> -t mangle -A XRAY -d <span class="hljs-number">100.64.0.0</span>/<span class="hljs-number">10</span> -j RETURN<br><span class="hljs-attribute">iptables</span> -t mangle -A XRAY -d <span class="hljs-number">127.0.0.0</span>/<span class="hljs-number">8</span> -j RETURN<br><span class="hljs-attribute">iptables</span> -t mangle -A XRAY -d <span class="hljs-number">169.254.0.0</span>/<span class="hljs-number">16</span> -j RETURN<br><span class="hljs-attribute">iptables</span> -t mangle -A XRAY -d <span class="hljs-number">172.16.0.0</span>/<span class="hljs-number">12</span> -j RETURN<br><span class="hljs-attribute">iptables</span> -t mangle -A XRAY -d <span class="hljs-number">224.0.0.0</span>/<span class="hljs-number">3</span> -j RETURN<br><span class="hljs-attribute">iptables</span> -t mangle -A XRAY -d <span class="hljs-number">255.255.255.255</span>/<span class="hljs-number">32</span> -j RETURN<br><span class="hljs-attribute">iptables</span> -t mangle -A XRAY ! -s <span class="hljs-number">192.168.0.0</span>/<span class="hljs-number">16</span> -j RETURN<br><span class="hljs-attribute">iptables</span> -t mangle -A XRAY -d <span class="hljs-number">192.168.0.0</span>/<span class="hljs-number">16</span> -p tcp -j RETURN<br><span class="hljs-attribute">iptables</span> -t mangle -A XRAY -d <span class="hljs-number">192.168.0.0</span>/<span class="hljs-number">16</span> -p udp ! --dport <span class="hljs-number">53</span> -j RETURN<br><span class="hljs-attribute">iptables</span> -t mangle -A XRAY -p tcp -j TPROXY --<span class="hljs-literal">on</span>-port <span class="hljs-number">12345</span> --tproxy-mark <span class="hljs-number">1</span><br><span class="hljs-attribute">iptables</span> -t mangle -A XRAY -p udp -j TPROXY --<span class="hljs-literal">on</span>-port <span class="hljs-number">12345</span> --tproxy-mark <span class="hljs-number">1</span><br><span class="hljs-attribute">iptables</span> -t mangle -A PREROUTING -j XRAY<br><br><span class="hljs-attribute">sleep</span> <span class="hljs-number">10</span><br><br><span class="hljs-attribute">ipv6</span>=$(ip -<span class="hljs-number">6</span> route show dev lo)<br><span class="hljs-attribute">ipv6_CIDR</span>=<span class="hljs-variable">$&#123;ipv6: 12: 24&#125;</span><br><span class="hljs-attribute">ip</span> -<span class="hljs-number">6</span> rule add fwmark <span class="hljs-number">1</span> table <span class="hljs-number">106</span><br><span class="hljs-attribute">ip</span> -<span class="hljs-number">6</span> route add local ::/<span class="hljs-number">0</span> dev lo table <span class="hljs-number">106</span><br><span class="hljs-attribute">ip6tables</span> -t mangle -N XRAY6<br><span class="hljs-attribute">ip6tables</span> -t mangle -A XRAY6 -d ::<span class="hljs-number">1</span>/<span class="hljs-number">128</span> -j RETURN<br><span class="hljs-attribute">ip6tables</span> -t mangle -A XRAY6 -d fe80::/<span class="hljs-number">10</span> -j RETURN<br><span class="hljs-attribute">ip6tables</span> -t mangle -A XRAY6 ! -s <span class="hljs-variable">$&#123;ipv6_CIDR&#125;</span> -j RETURN<br><span class="hljs-attribute">ip6tables</span> -t mangle -A XRAY6 -d <span class="hljs-variable">$&#123;ipv6_CIDR&#125;</span> -p tcp -j RETURN<br><span class="hljs-attribute">ip6tables</span> -t mangle -A XRAY6 -d <span class="hljs-variable">$&#123;ipv6_CIDR&#125;</span> -p udp ! --dport <span class="hljs-number">53</span> -j RETURN<br><span class="hljs-attribute">ip6tables</span> -t mangle -A XRAY6 -p udp -j TPROXY --<span class="hljs-literal">on</span>-port <span class="hljs-number">12345</span> --tproxy-mark <span class="hljs-number">1</span><br><span class="hljs-attribute">ip6tables</span> -t mangle -A XRAY6 -p tcp -j TPROXY --<span class="hljs-literal">on</span>-port <span class="hljs-number">12345</span> --tproxy-mark <span class="hljs-number">1</span><br><span class="hljs-attribute">ip6tables</span> -t mangle -A PREROUTING -j XRAY6<br></code></pre></td></tr></table></figure><h2 id="与参考文章相比，我做出哪些改变？"><a href="#与参考文章相比，我做出哪些改变？" class="headerlink" title="与参考文章相比，我做出哪些改变？"></a>与参考文章相比，我做出哪些改变？</h2><p>事实上，我主要增加了 ipv6 的部分，即便是 <a href="https://xtls.github.io/document/level-2/tproxy_ipv4_and_ipv6.html">这篇</a>，也仅仅针对使用 nat6 的网络，我相信使用 ipv6 肯定是图它全球单播的优点，不然我觉得直接关闭 ipv6 是更省事的做法（使用 fd00::&#x2F;8 是 unacceptable！！！）<br>但是针对我国 ISP 使用的动态 ipv6-pd 的问题，每次重新拨号都会使前缀变化，网段肯定不能写死在配置里，因此随系统启动时要能主动获取当前的网段：</p><ol><li>运行<code>ip -6 route show dev lo</code>获取本机的 ipv6 网段信息</li><li><code>ipv6_CIDR=$&#123;ipv6: 12: 24&#125;</code>截取网段信息</li></ol><ul><li>注意<code>ip -6 route show dev lo</code>时可能会返回多个 ipv6 地址，注意区分哪个是 pd 前缀</li><li><code>sleep 10</code>是为了等待 pppoe 拨号，拨号后才可能下发前缀</li></ul><h1 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h1><p>实际上，调 iptables 的配置，不能说是一番风顺吧，只能说是举步维艰<br>一些很快被发现的小问题就不说了。<del>几次写错 iptables 的规则导致 ssh 都访问不到路由器，只能断电重启</del></p><p>一开始，我对 DNS 的处理是这样的</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">iptables</span> -t mangle -A XRAY -d <span class="hljs-number">192.168.0.0</span>/<span class="hljs-number">16</span> -p tcp ! --dport <span class="hljs-number">53</span> -j RETURN<br><span class="hljs-attribute">iptables</span> -t mangle -A XRAY -d <span class="hljs-number">192.168.0.0</span>/<span class="hljs-number">16</span> -p udp ! --dport <span class="hljs-number">53</span> -j RETURN<br></code></pre></td></tr></table></figure><p>而我的 xray 路由中却是只有</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<br>    <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;field&quot;</span>,<br>    <span class="hljs-string">&quot;inboundTag&quot;</span>: [<br>        <span class="hljs-string">&quot;all-in&quot;</span><br>    ],<br>    <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">53</span>,<br>    <span class="hljs-string">&quot;network&quot;</span>: <span class="hljs-string">&quot;udp&quot;</span>,<br>    <span class="hljs-string">&quot;outboundTag&quot;</span>: <span class="hljs-string">&quot;dns-out&quot;</span><br>&#125;,<br></code></pre></td></tr></table></figure><p>这就导致了局域网请求 TCP 53 时，走了<code>direct</code>，这条DNS出了 xray 又进了系统 DNS 查询，系统就先对自己的 TCP 53 端口进行了 DNS 查询，于是这条 DNS 又进了 xray，在这种递归之下，很快，xray 日志里出现了大量这样的日志</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">2023/07/26</span> <span class="hljs-number">14:12:10 192</span>.<span class="hljs-number">168.2.2</span>:<span class="hljs-number">59754</span> accepted udp:<span class="hljs-number">192.168.2.1</span>:<span class="hljs-number">53</span> [all-in -&gt; dns-out]   //udp 请求就不会，因为它正常的路由到了 dns-out<br><span class="hljs-number">2023/07/26</span> <span class="hljs-number">14:12:10 192</span>.<span class="hljs-number">168.2.2</span>:<span class="hljs-number">51312</span> accepted tcp:<span class="hljs-number">192.168.2.1</span>:<span class="hljs-number">53</span> [all-in -&gt; direct]    //这条开始引起了下面反复请求<br><span class="hljs-number">2023/07/26</span> <span class="hljs-number">14:12:10 192</span>.<span class="hljs-number">168.2.1</span>:<span class="hljs-number">34072</span> accepted tcp:<span class="hljs-number">192.168.2.1</span>:<span class="hljs-number">53</span> [all-in -&gt; direct]    //这样的请求在实际日志中持续了上百条，这里只是节选<br><span class="hljs-number">2023/07/26</span> <span class="hljs-number">14:12:10 192</span>.<span class="hljs-number">168.2.1</span>:<span class="hljs-number">34080</span> accepted tcp:<span class="hljs-number">192.168.2.1</span>:<span class="hljs-number">53</span> [all-in -&gt; direct]<br><span class="hljs-number">2023/07/26</span> <span class="hljs-number">14:12:10 192</span>.<span class="hljs-number">168.2.1</span>:<span class="hljs-number">34094</span> accepted tcp:<span class="hljs-number">192.168.2.1</span>:<span class="hljs-number">53</span> [all-in -&gt; direct]<br></code></pre></td></tr></table></figure><p>在这之后不久，软路由系统就卡死，网络完全崩了</p><p><del>当时看了半天 iptables 的原理，脑子完全僵住了，还以为是 xray 的问题，还去提了个 issue</del></p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>折腾这玩意最好先在其他设备调好再转到主路由上去，<del>否则可能引起家庭矛盾</del>，而且这一套规则可能之后还会再调，目前还发现了不少小问题</p><p>emmmmm，以后再写吧！</p>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
      <tag>Tproxy</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
